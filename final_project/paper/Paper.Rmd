---
title: "Genome Function Phylogenetics"
author: "Dennis Psaroudakis"
date: "April 18th 2019"
keep_md: yes
output:
  tufte::tufte_handout:
    latex_engine: xelatex
    citation_package: natbib
  tufte::tufte_html: default
bibliography: resources/bib.bib
link-citations: yes
classoption: justified
language: en-US
header-includes:
  - \usepackage[osf]{libertine}
  - \citestyle{plain}
---

```{r setup, include=FALSE}
library(tufte)
# invalidate cache when the tufte version changes
knitr::opts_chunk$set(tidy = FALSE, cache.extra = packageVersion('tufte'))
options(htmltools.dir.version = FALSE)
```

`r newthought("When we build phylogenetic trees,")` we often use the sequences of certain genes as the basis for our tree.
They are the direct substrate of evolution so that makes sense, but practically often too abstract to be helpful.
Let's say for example, that you have a patient infected with a novel pathogen.
You can identify that pathogen and place it somewhere in the bacterial taxonomy, but unfortunately, none of the treatments that you usually use for closely related species show any effect against this one.
How come?
Just because two organisms are closely related does not *necessarily* mean that they are similar in their phenotype.
So a tree that groups organisms based on their actual *in vivo* similarity would be much more helpful here.
There are such trees built on phenotypic characteristics but unfortunately the choice of what characteristics to look at is not trivial and always situation-dependent.
They can also be considered quite arbitrary\sidenote{
Look at this (parodic) taxonomy of animals by Jorge Luis Borges:
1. those that belong to the Emperor,
2. embalmed ones,
3. those that are trained,
4. suckling pigs,
5. mermaids,
6. fabulous ones,
7. stray dogs,
8. those included in the present classification,
9. those that tremble as if they were mad,
10. innumerable ones,
11. those drawn with a very fine camelhair brush,
12. others,
13. those that have just broken a flower vase,
14. those that from a long way off look like flies.
}.
What's needed would be something that is exhaustive, clearly defined, and reproducible, but also more meaningful than just a DNA sequence.
And they did it [@Zhu2015]!

In this paper, I'm going to do something slightly similar. Not on bacteria, but on plants though.
I know, disapointing, but I'll find a similarly fascinating reason why that's important soon.
So, to summarize: I want to build a phylogenetic tree on plant species not based on their genetic sequence but on the *functions* that this plant is able to execute.

# The Gene Ontology
Historically, the function/role that a gene plays in an organism has always been described in natural language, however the researcher characterizing that gene deemed best.
While this is nice to read, it is not very useful if you want to do computation on it, as computers are (still) horrible at understanding natural language and determining the structure in meaning behind the words.
Additionally, different people will describe the same thing with different words, which has the potential for misunderstanding.

Ontologies try to alleviate these problems by providing a strictly organized and controlled vocabulary and defined relationships between the terms, so that the same statement always means the same thing, no matter the context or the  author. Additionally, ontologies can be understood by computers if all relationships and terms are clearly defined.

The Gene Ontology (GO) is such an ontology that describes genes by the properties of their product.
\marginnote{"The mission of the GO Consortium is to develop an up-to-date, comprehensive, computational model of biological systems, from the molecular level to larger pathways, cellular and organism-level systems."

\raggedleft --- GO Consortium (geneontology.org)}
In our case these gene products are proteins, and they can be characterized in three different aspects:

- What biological processes is this protein part of? (e.g. photosynthesis or autophagy)
- What molecular functions does the protein carry out? (e.g. ethylene binding or RNA ligation)
- What cellular component is the protein active at? (e.g. outer membrane or nucleus)

Within each of these aspects, the Gene Ontology defines a huge number of terms (2,675,070 in total), that range from very general to very specific:


![subtree of the *Biological Process* ontology. 
The terms are organized in such a way that more general terms are always true for any of their more specific child terms.
For example, any protein that is part of *Cytokinesis after Meiosis I*, is also obviously part of Cytokinesis, the Cell Cycle etc.
That way, a gene that has been annotated with the term *Cytokinesis after Meisosis I* (leaf term), has implicitly been annotated with all of that term's parent terms as well, all the way up to the root term.](resources/go_hierarchy_example.png){width=60%}

\noindent When proteins are annotated with these terms instead of just natural language, we can now computationally answer some interesting questions, such as:

- How similar in function is protein A to protein B? (One answer would be: How many steps in the GO graph do I need from term A to B? The fewer steps, the more similar the function)
- If protein A is involved in Biological Process XYZ, what other proteins are involved in that same process?

\noindent The Gene Ontology is quite well established in the field, so you will find GO annotations for almost all relevant UniProt entries or use dedicated tools like AmiGO or QuickGO to examine a protein of interest.

# Data
Annotating genes with their functions can be done experimentally (e.g. by knocking out a certain gene and seeing what processes in the cell are affected), but that is a time-consuming and expensive process, so methods have been developed that try and predict the function of a given gene.
Our lab has developed such a pipeline called GOMAP which combines different prediction approaches and is able to generate high-confidence and very extensive Functional Annotations in a reproducible manner [@Wimalanathan2018].
We have been applying this pipeline to whole-genome assemblies of different plant species and generated functional annotations for every gene in each genome.
These annotation sets are (or will be shortly) available from  
\scriptsize https://dill-picl.org/projects/gomap/gomap-datasets \normalsize.

# Method
I am using two different tree building approaches, one is a distanced based method and the other a parsimony one.

## Distance Based
Starting point of our analysis are the functional annotation sets, one for each genome, which annotate every gene in the genome with one or more GO terms.
In more mathematical terms the genome annotation set is a list of tuples $(G, T)$ with $G \in$ Genes in that genome and $T \in$ Terms in the Gene Ontology.
\marginnote[-5em]{
\texttt{Gene\ \ \ \ \ \ \ \ \ GO Term\\
Os01g0601625	GO:0050896\\
Os01g0601625	GO:0016021\\
Os01g0601625	GO:0016301\\
Os01g0601651	GO:0003677\\
Os01g0601651	GO:0009699\\
Os01g0601651	GO:0050790\\
Os01g0601651	GO:0050794\\
Os01g0601651	GO:0050896\\
Os01g0601675	GO:0007275\\
Os01g0601675	GO:0016310\\
Os01g0601675	GO:0050789\\
...
}
}

We can use the hierarchical structure of the Gene Ontology to obtain the ancestors $A_i$ of any term $T_i$; in other words the gene $G_i$ is not just annotated with the term $T_i$ itself but also with all GO terms that are a more general statement of that term (e.g. any gene that is part of a metabolic process is thereby also part of a biological process).
We do that for all terms $T$ in the dataset and combine all of the terms and their ancestors into one big genome-wide set $S$, irrespectively of the gene they were originally associated with:  $S = \bigcup_{i=1}^{x}(T_i \cup A_{i})$.

When this superset of annotations is created for each of the datasets, we can use the Jaccard Distance as a measure of how (dis-)similar any two sets are from each other, or in biological terms how different the two genomes are on a functional level:

$$ \textrm{Jaccard Distance}(S_a, S_b) = 1 - \frac{|S_a \cap S_b|}{|S_a \cup S_b|} $$

\begin{marginfigure}
The general idea of using the Jaccard Distance in this context is to measure the overlap of two subtrees in the GO hierarchy.
Say, for simplicity, that we're looking at two genomes (here called Gold Standard and Prediction) that each only contain one single GO term (marked by a leaf).
First, we add all ancestors of that leaf term to each subtree.
Then, we determine the overlap (which corresponds to $S_a \cap S_b$), and divide the number of nodes in this overlap by the number of nodes in either of the two subtrees ($S_a \cup S_b$).
\vspace{0.2em}

\includegraphics{resources/hF-graphical.png}

\vspace{0.5em}
\noindent In the case of this example, the Jaccard Distance of Gold Standard and Prediction would be $1 - \frac{4}{9} = \frac{5}{9}$
\end{marginfigure}

Applying this formula to all pairwise combinations of the genomes we're looking at yields a $S \times S$ distance matrix that can then serve as the input for a neighbor joining algorithm (provided by PHYLIP).
I rooted the resulting tree manually outside of the grasses (maize, wheat, rice, barley).

## Parsimony Based

Like in the previous method, we again start by enriching all taxa sets $(G,T)$ with their ancestor terms and discarding the gene association: $S = \bigcup_{i=1}^{x}(T_i \cup A_{i})$.

Instead of using these sets for distance calculation, we combine them into a big binary matrix that displays which terms are present in which set:

\begin{table}[]
\begin{tabular}{lllllll}
Taxon       & \scriptsize{GO:0016021} & \scriptsize{GO:0009699} & \scriptsize{GO:0050794} & \scriptsize{GO:0050789} & \scriptsize{GO:0060739} & ... \\
\textit{G. max}      & 1          & 0          & 1          & 0          & 1          &     \\
\textit{T. aestivum} & 1          & 1          & 0          & 1          & 1          &     \\
...         &            &            &            &            &            &    
\end{tabular}
\end{table}

This matrix was then used as the input for `pars` from the PHYLIP package to find the maximally parsimonious tree.

# Results

The phylogram created by the distance based method is displayed in Figure \ref{fig:result}, the maximum parsimony tree in figure \ref{fig:parsimony}.

\begin{figure*}[htbp]
\includegraphics{resources/result.png}
\caption{Phylogram built on the Jaccard distance matrix with Neighbor Joining. Manually rooted between monocots and dicots and text in green added.}
\label{fig:result}
\end{figure*}

\begin{figure*}[htbp]
\includegraphics{resources/parsimonyTree.png}
\caption{Phylogram built by looking for the maximally parsimonious tree (total of 7780 changes). Manually rooted between monocots and dicots.}
\label{fig:parsimony}
\end{figure*}

Both trees were combined into a tanglegram (see figure \ref{fig:tanglegram}).

\begin{figure*}[htbp]
\includegraphics{resources/tanglegram.png}
\caption{Tanglegram of the distance based and maximum parsimony tree (both manually rooted).}
\label{fig:tanglegram}
\end{figure*}

# Discussion

This tree shows surprising similarity to the taxonimic tree one might expect if it had been built on sequences^[I should probably display that expected tree here.]:
The maize cultivars are all grouped together and there's even the distinction between the non-stiff stalk (W22 and Mo17), iodent (Ph207), and stiff stalk (maize_v4) classes.
Only maize_v3, which is the same cultivar as maize_v4 (B73) is waaaay out there where it probably doesn't belong.
We're currently investigating this but it seems that a lot went wrong with the genome assembly itself, which would naturally influence the functional annotations derived from it.
The two medicago genotypes, while correctly placed together in one clade, are an outlier to the other legumes.
In a taxonomic tree, their place would be switched with peanut.
Steven Cannon, who is an evolutionary biologist working on legumes, assumes that the reason for that is that medicago has a much higher rate of evolution and gene birth and death than other plants [@Young2011].
As you will have noticed, this is all just a work in progress at the moment. My PI and I will meet with Steven on Monday and discuss (among other things) the following questions -- feel free to comment in your review if you have any input!

- How similar is this tree to the taxonomic tree?
- What are the reasons for the differences, what are the reasons for the similarities?
- What biases in the construction process need we be aware of?
- What does the tree depict/how do we interpret it?
- In what way could it be scientifically valuable?
- Are there any other taxa that would be good to have in the tree?
- Is there any further analysis that would be good to do? (e.g. branch support, looking at each GO aspect separately, a more sophisticated measure of GAF similarity, trying a character state based method instead of distance...)
- Is rooting the tree there reasonable?


The tree is surprisingly similar to the taxonomic tree one might expect if it had been built on sequences^[I should probably display that expected tree here.], but why did it work so well?
Given the number of taxa, it is unlikely that it is due to pure chance or noise but it is not clear whether this tree actually demonstrates a biologically meaningful difference in the functional annotations of these species or wehther it is simply a reproduction of some bias or artifact that stems from some element in the process.

To further examine this question, I wanted to see where the phylogenetic signal actually comes from.
So I asked the following question: Which terms are common to all nitrogen fixing plants but do not occur in any other plant in the tree?^[in mathy words this is the intersection of terms in the nitrogen fixing species minus the union of terms in all other species]
If these terms are actually meaningful to the process of nitrogen fixation (or some other characteristic that clearly differentiates this group of plants from the others) that would indicate that the phylogenetic signal actually comes from biologically plausible differences in the functional annotations.
So, here is the answer:

- GO:0080184 - response to phenylpropanoid
- GO:0033800 - isoflavone 7-O-methyltransferase activity
- GO:0042577 - lipid phosphatase activity
- GO:0031174 - lifelong otolith mineralization
- GO:0045299 - otolith mineralization
- GO:0006742 - NADP catabolic process
- GO:0019364 - pyridine nucleotide catabolic process
- GO:0019677 - NAD catabolic process
- GO:0070823 - HDA1 complex

Three of these terms do seem plausible: The Nod Factor molecule that is secreted by the plant as a signal to Rhizobia bacteria is a phenylpropanoid, isoflavone 7-O-methyltransferase activity is involved in Nod Factor synthesis, and the nodule has a complex lipid membrane system – and Nod Factor has a lipid component (which could explain lipid phosphatase activity).
The last 4 terms are possibly plausible, but less certain, but the two otolith terms seem very out of place, since they describe small oval calcareous bodies in the inner ear of vertebrates, not something expected to be found in legumes.

## Reproducing the Tree
To reproduce this tree, follow these steps on a Linux machine that has PHYLIP available:

```bash
git clone https://github.com/Thyra/EEOB563.git paper_dennis # Clone the repository
cd paper_dennis/final_project # change into the directory
./build_distance_matrix > infile
module load phylip # (if you're on HPC)
neighbor # (use standard options)
```

\noindent The resulting tree is in `outtree`.
Manually root it (e.g. with Dendrogram) outside of the grasses (maize, wheat, barley) and you should end up with the same tree.
This will use the pre-summarized `.tree.json` files in annotation_sets, if you want to completely reproduce it from scratch, delete them and only leave the `.gaf.gz` files.
But be warned, this will take a while to calculate (probably over two hours).